# 人工智能基础_第一次大作业实验报告
> 新雅62/CDIE6 2016013327 项雨桐

> 2019.10.19
[TOC]
## 1. 任务描述
### 1.1 问题要求
本问题的要求是移动1到2根火柴棍使等式成立,并且给出从等式变为等式的问题集和难度,本次作业涉及的数字位数不超过两位

等式的来源可以分为:
* 现有等式库
* 用户输入
* 随机生成

### 1.2 问题集说明
本次作业使用的问题集有:
* ``resources/equations.txt``: 变换一个火柴棍问题的问题集,来源于谷歌图片搜索,共计56题
* ``resources/equations2.txt``: (选做4)变换两个火柴棍问题的问题集,来源于谷歌图片搜索,共计15题
* ``resources/equations637.txt``: (选做5)衡量等式变等式难度的问题集,使用``python``函数直接生成后去重得到

## 2. 问题建模
### 2.1 问题约定
#### 2.1.1 非负数约定
本作业所涉及的所有数字都是非负的,任何情况下不允许负数出现
#### 2.1.2 高位零约定
本作业的输入和结果均不允许十位为数字``'0'``的情况出现(但可以为空)
#### 2.1.3 低位空约定
本作业的结果允许低位数字变为空,此时视为数值为高位数字的个位数
#### 2.1.4 分离约定
本作业的结果不允许将输入的一位数字经变换之后视为两位数,也即不允许诸如``'4'``去掉一根火柴棍变为``'11'``的情况出现

### 2.2 数码映射
本次作业利用长度为7的 ``01``字符串对各个数位进行编码,编码的方式如下:

<img src = '01.png' width = "20%"></img>

图中数字分别对应于字符串中字符的索引值(加一),当该数位有火柴棍是记为``'1'``,否则记为``'0'``,例如``'2'``对应的字符串序列为``'1011101'``

需要特殊说明的是,本次作业允许出现``'0100100'``代表``'1'``,``'0101111'``代表``'6'``,``'1111010'``代表``'9'``的情况,但在解析已有公式时,还是按照常规的数码显示方式来解析.

### 2.3 火柴棍变动与字符串的汉明距
#### 2.3.1 [汉明距](https://www.wikiwand.com/zh-hans/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB)
在信息论中，两个等长字符串之间的汉明距离是两个字符串对应位置的不同字符的个数。 换句话说，它就是将一个字符串变换成另外一个字符串所需要替换的字符个数.

汉明距的这些性质使之能很好地描述已映射成定长字符串的火柴棍数位的变化.

#### 2.3.2 用汉明距描述某数位火柴棍的变化
对于某一个数位,一次移动火柴棍的变化有三种形式:
* 数位内火柴棍位置的移动,记为``same1``
* 减少一根火柴棍,记为``minus1``
* 增加一根火柴棍,记为``plus1``

不同的变化前后产生的结果对应于不同的汉明距和字符串中``1``的个数的变化:
* ``same1``: 变化前后的字符串中``1``的个数相同,二者汉明距为``2``
* ``minus1``: 变化前的字符串比变化后字符串``1``的个数少一,二者汉明距为``1``
* ``plus1``: 变化前的字符串比变化后字符串``1``的个数多一,二者汉明距为``1``

火柴棍的七位数字编码方式总共对应于128个节点,而移动一根火柴棍产生的三种变化构成了由这128个节点组成的三张子图.这些子图在程序中被构建在``dict``里(链表形式存储的图结构)

### 2.4 数位状态转换
规定了一次火柴棍移动后某个数位状态的变化之后,就可以将这些变化视为原子,从而定义整个算式在若干次火柴棍移动后的状态变化,那些满足相等关系的新状态就是我们要求得的解.

设每个数位为一个节点``node``,不同的数位以不同的数字区分.

#### 2.4.1 移动一根火柴
移动一根火柴使等式成立有下列三种状态转换方式:

* ``[node1:same1]``
* ``[node1:minus1, node2:plus1]``
* ``[node1:plus1, node2:minus1]``

``minus1``和``plus1``是对称的过程,我们可以通过规定动作发生的节点顺序来除去对称情况,也即约定发生在前面的动作只发生在从左到右读取时靠前的节点.这里``node2``是``node1``之后的节点
#### 2.4.2 移动两根火柴
移动两根火柴使等式成立可以视为移动一根火柴的步骤重复两次得到.

对于一个节点有三种搜索方法,但若一个节点发生了``plus1``或者``minus1``的操作,则必有另外一个节点发生对应的操作.

需要注意的是,为了排除对称情况,第一次``same1``操作后的``same1``操作从当前节点开始向后搜索;每次``minus1``或者``plus1``操作之后对应的操作从下一个节点开始;两组操作相互独立

综上,移动两根火柴棍总共有下列九种状态转换方式:

1. ``[node1:same1(same1)]`` 或 ``[node1:same1, node2:same1]``
2. ``[node1:minus1(same1), node2:plus1]`` 或 ``[node1:same1, node2:minus1, node3:plus1]``
3. ``[node1:plus1(same1), node2:minus1]`` 或 ``[node1:same1, node2:plus1, node3:minus1]``
4. ``[node1:minus1, node2:plus1, node3:same1]``
   * ``node3``可以为``node1``及其之后的任意一个节点
5. ``[node1:minus1, node2:plus1, node3:minus1, node4:plus1]``
   * 只需要保证``node2``在``node1``之后,``node4``在``node3``之后,``node3``可以为``node1``及其之后的任意一个节点
6. ``[node1:minus1, node2:plus1, node3:plus1, node4:minus1]``
   * 只需要保证``node2``在``node1``之后,``node4``在``node3``之后,``node3``可以为``node1``及其之后的任意一个节点
7. ``[node1:plus1, node2:minus1, node3:same1]``
   * ``node3``可以为``node1``及其之后的任意一个节点
8. ``[node1:plus1, node2:minus1, node3:minus1, node4:plus1]``
   * 只需要保证``node2``在``node1``之后,``node4``在``node3``之后,``node3``可以为``node1``及其之后的任意一个节点
9.  ``[node1:plus1, node2:minus1, node3:plus1, node4:minus1]``
    * 只需要保证``node2``在``node1``之后,``node4``在``node3``之后,``node3``可以为``node1``及其之后的任意一个节点

### 2.5 操作符的变化
#### 2.5.1 移动一根火柴
移动操作符的一根火柴或移动一根火柴到操作符使等式成立总共有如下三种情况:

1. ``-``和``=``互调:重新计算
2. ``-``变成``+``:某数位发生了``minus1``操作
3. ``+``变成``-``:某数位发生了``plus1``操作

#### 2.5.2 移动两根火柴
##### 2.5.2.1 移位问题
由于所有的算符都由至多两根火柴组成,所以可能通过包含操作符位置的变化的方法使等式成立,称这类问题为移位问题.

根据我们之前的约定,移位发生的前提是不出现三位及以上的数.根据三个操作数是否为空位可以将等式分为八种类型,现考察对于不同的操作符,它们可能通过移位操作获得所需结果的情形,展示如下:

<img src = '02.jpg' width = "80%"></img>

##### 2.5.2.2 变符号问题
符号位置不变但类型变化的问题称为变符号问题.根据操作符的不同可以总结为如下几种:
1. 原操作符为``-``:
   * ``-`` 变成 ``+``: 原有某数位进行``minus1``操作后得到的新节点集再进行只包含数位变化的移动一根火柴的搜索
   * ``-`` 变成 ``*``: 原有某数位进行``minus1``操作后再变成``*``
   * ``-`` 变成 ``=``:
     * 将``=``的一根火柴棍移动到``-``处,再对数位进行只包含数位变化的移动一根火柴的搜索
     * 将数位中的一根火柴棍进行``minus1``操作后移动到``-``处,再将``=``变成``+``
     * 将数位中的一根火柴棍进行``minus1``操作后移动到``-``处,再将``=``中的一根火柴棍移动到数位进行``plus1``操作
     * 将``=``中的一根火柴棍移动到数位进行``plus1``操作,再将数位中的一根火柴棍进行``minus1``操作后移动到``-``处
2. 原操作符为``+``:
	* ``+`` 变成 ``-``: 原有某数位进行``plus1``操作后得到的新节点集再进行只包含数位变化的移动一根火柴的搜索
	* ``+`` 变成 ``*``: 直接转换
	* ``+`` 变成 ``=``:
    	* 直接转换
    	* 将``+``变成``=``, 将``=``中的一根火柴棍移动到数位进行``plus1``操作
3. 原操作符为``*``:
    * ``*`` 变成 ``-``: 将``*``中的一根火柴棍移动到数位进行``plus1``操作,再变成``-``
    * ``*`` 变成 ``+``: 直接转换

### 2.6 计算等式之间转换的难度
#### 2.6.1 汉明距与转换难度
如果将每个数位都编码成``01``字符串,并且能为操作符找到一种合适的编码方式的话,那么某个给定的等式就可以编码成一系列``01``字符串,等式之间的转变就用字符串之间的转变来表示.等式之间的状态转换满足前后``01``字符串中``1``的个数保持不变;而给定两个火柴棍数目相等的公式,则一定能在有限步骤之内完成转换.

对于转换难度,最直观的定义就是移动火柴棍的次数.对于``01``字符串,则可视为两串之间的编辑距离;特别地,对于``1``的个数相同的两个字符串,前面所述的汉明距一定是偶数,这个数的一半就是火柴棍的移动数目,也即等式之间转换的难度.从此出发设计我们的算法.

#### 2.6.2 操作符的编码
上面的讨论只限于数位的编码.对于操作符而言,由于其形态的特殊性,导致自然编码 ( ``1``的个数代表火柴棍数目,编码间的汉明距为操作次数 ) 并不能实际反映转换难度.因此若想用字符串的汉明距来表征等式转换的操作次数,就需要为操作符设计一套编码,这套编码需要既能反映操作符使用的火柴棍数目,又要能通过汉明距来表达操作次数.

从一套可能的自然编码开始:

符号 | 编码
-- | --
``-`` | ``0001``
``+`` | ``0011``
``*`` | ``0101``
``=`` | ``1001``

再计算符号之间转换实际需要的操作次数:

<img src = '03.jpg' width = "40%"></img>

从中可以看出只有从``-``和``*``、``+``和``=``之间不满足汉明距与操作次数相等的条件,且一个需要``+1``一个需要``-1``,因此还需要增加两位编码如下:

符号 | 编码1 | 编码2
-- | -- | --
``-`` | ``0001`` | ``00``
``+`` | ``0011`` | ``01``
``*`` | ``0101`` | ``11``
``=`` | ``1001`` | ``10``

若两个串的编码2之间编辑距离是``2``,则修改利用编码1计算的汉明距:
* 若编码2的两个位相同,则原来的汉明距``+1``
* 若编码2的两个位相异,则原来的汉明距``-1``

否则沿用原来编码1的汉明距

由此我们就实现了字符串汉明距之间到转换难度的映射(程序中编码2和编码1的位置是颠倒的)

另外,这种算法并未考虑算符移位的情形


## 3. 算法设计与实现
### 3.1 移动一根火柴
该过程的伪码如下:
```py
for node1 in [node_start:node_end]:
	nodeA = same1(node1)#[node1:same1]

for node1 in [node_start:node_end]:
	nodeA = minus1(node1)
	for node2 in [next(node(A)):node_end]:
		nodeB = plus1(node2)#[node1:minus1, node2:plus1]

for node1 in [node_start:node_end]:
	nodeA = plus1(node1)
	for node2 in [next(node(A)):node_end]:
		nodeB = minus1(node2)#[node1:plus1, node2:minus1]
```

### 3.2 移动两根火柴
该过程的伪码如下(深度优先搜索):

1. 第一个节点是``same1``
```py
for node1 in [node_start:node_end]:
	nodeA = same1(node1)
	for node2 in [nodeA:node_end]:
		nodeB = same1(node2)# [node1:same1(same1)] 或[node1:same1, node2:same1]
	for node2 in [nodeA:node_end]:
		nodeB = minus1(node2)
		for node3 in [next(node(B)):node_end]:
			nodeC = plus1(node3)# [node1:minus1(same1), node2:plus1] 或 [node1:same1, node2:minus1, node3:plus1]
	for node2 in [nodeA:node_end]:
		nodeB = plus1(node2)
		for node3 in [next(node(B)):node_end]:
			nodeC = minus1(node3)# [node1:plus1(same1), node2:minus1] 或 [node1:same1, node2:plus1, node3:minus1]
```
2. 第一个节点是``minus1``
```py
for node1 in [node_start:node_end]:
	nodeA = minus1(node1)
	for node2 in [next(nodeA):node_end]:
		nodeB = plus1(node2)
		for node3 in [nodeA:node_end]:
			nodeC = same1(node3)#[node1:minus1, node2:plus1, node3:same1], (node3可以为node1及其之后的任意一个节点)
		for node3 in [node(A):node_end]:
			nodeC = minus1(node3)
			for node4 in [next(nodeC):node_end]:
				nodeD = plus1(node4)# [node1:minus1, node2:plus1, node3:minus1, node4:plus1], (只需要保证node2在node1之后,node4在node3之后,node3可以为node1及其之后的任意一个节点)
		for node3 in [nodeA:node_end]:
			nodeC = plus1(node2)
			for node4 in [next(node(C)):node_end]:
				nodeD = minus1(node3)# [node1:minus1, node2:plus1, node3:plus1, node4:minus1], (只需要保证node2在node1之后,node4在node3之后,node3可以为node1及其之后的任意一个节点)
```
3. 第一个节点是``plus1``
```py
for node1 in [node_start:node_end]:
	nodeA = plus1(node1)
	for node2 in [next(nodeA):node_end]:
		nodeB = minus1(node2)
		for node3 in [nodeA:node_end]:
			nodeC = same1(node3)#[node1:plus1, node2:minus1, node3:same1], (node3可以为node1及其之后的任意一个节点)
		for node3 in [node(A):node_end]:
			nodeC = minus1(node3)
			for node4 in [next(nodeC):node_end]:
				nodeD = plus1(node4)# [node1:plus1, node2:minus1, node3:minus1, node4:plus1], (只需要保证node2在node1之后,node4在node3之后,node3可以为node1及其之后的任意一个节点)
		for node3 in [nodeA:node_end]:
			nodeC = plus1(node2)
			for node4 in [next(node(C)):node_end]:
				nodeD = minus1(node3)# [node1:plus1, node2:minus1, node3:plus1, node4:minus1], (只需要保证node2在node1之后,node4在node3之后,node3可以为node1及其之后的任意一个节点)
```
### 3.3 等式转换难度
#### 3.1 匹配
对任意两个等式, 若表示两个等式的数位串+编码1串的``1``的个数相同即表示两个等式可以在有限步骤内完成转换

#### 3.2 难度计算
从一个等式变为另一个等式的难度即为两式对应字符串修正之后的汉明距的一半

## 4. UI设计与使用说明
### 4.1 主界面
主界面是程序开始时进入的界面,界面左侧是算式显示区域,右侧是按钮栏,分别有三个按钮:
* ``移动一根``:选择移动一根火柴
* ``移动两根``:选择移动两根火柴
* ``等式转变``:选择查看等式转变的题目和难度

点击按钮进入相应的二级界面
## 4.2 二级界面1
二级界面1是选择``移动一根``和``移动两根``会进入的公共界面,左侧是算式显示区域,右侧是按钮栏, 分别有四个按钮:

* ``从题库加载``:加载已有的算式库
* ``输入算式``:选择自行输入算式
* ``随机生成``:运用函数随机生成算式
* ``返回``:返回主界面

点击按钮进入相应的操作界面
### 4.2.1 从题库加载
进入该操作界面后,程序会根据用户之前的选择(``移动一根``,``移动两根``)加载对应的算式库.

与此同时,其他按钮消失,只留下``返回``键,左上方出现``“请选择一个题库中的算式``的组合框选项

点击组合框选择待解决的算式

选择好算式之后,下方的显示区将会给出原有的算式和移动之后的结果;如果没有解,则会显示相应的提示弹窗,点击确定即可.这时组合框旁边出现一个``清空``按钮.

点击``清空``之后,可重复选择算式

> 注意: 每次选择算式得出结果之后一定要点击清空,否则原有的算式不会自动消失,会导致显示错误

点击``返回``回到主界面

### 4.2.2 输入算式
进入该操作界面后,其他按钮消失,只留下``返回``键,左上方出现``“请输入一个算式``的单行文本框

点击文本框,输入待解决的算式,按下回车键

这时,下方的显示区将会给出原有的算式和移动之后的结果;如果没有解,则会显示相应的提示弹窗,点击确定即可.这时组合框旁边出现一个``清空``按钮.

点击``清空``之后,可重复输入算式

> 注意: 每次选择算式得出结果之后一定要点击清空,否则原有的算式不会自动消失,会导致显示错误

点击``返回``回到主界面

### 4.2.3 随机生成
进入该操作界面后,其他按钮消失,只留下``返回``键,左上方出现``生成算式``的按钮

点击按钮,下方的显示区将会给出原有的算式和移动之后的结果;如果没有解,则会显示相应的提示弹窗,点击确定即可.这时组合框旁边出现一个``清空``按钮.

点击``清空``之后,可重复生成算式

> 注意: 每次选择算式得出结果之后一定要点击清空,否则原有的算式不会自动消失,会导致显示错误

点击``返回``回到主界面

### 4.3 二级界面2
二级界面2是选择``等式转变``会进入的界面,左侧是算式显示区域,右侧是按钮栏, 分别有两个按钮:

* ``等式库加载``:加载已有的等式库
* ``返回``:返回主界面

### 4.3.1 等式库加载
进入该操作界面后,程序会加载已有的等式库

与此同时,其他按钮消失,只留下``返回``键,左上方出现``“请选择一个题库中的算式``的组合框选项

点击组合框选择待解决的算式

选择好算式之后,下方的显示区将会给出原有的算式,这时组合框旁边出现``显示结果``和``清除``按钮, 右上角出现``难度系数``和``剩余答案数``的显示区

点击``显示结果``之后,界面下方出现可行的结果, 右上角开始显示``难度系数``和``剩余答案数``

点击``清除``,再点击``显示结果``,则会显示下一条可行的结果,右上角的``难度系数``和``剩余答案数``被更新

> 注意事项: 每次显示结果之后一定要点击清空,否则原有的算式不会自动消失,会导致显示错误

反复点击``清除``和``显示结果``,直至所有可行的结果显示完毕,这时程序会弹出消息框提示, 原有等式被清除, 这时可另外选择等式

点击``返回``回到主界面

## 5. 实验总结
### 5.1 搜索算法
搜索算法是人工智能领域最基础的算法,各类搜索算法被广泛应用于解决实际问题,本作业即为一例.

对于搜索算法,问题的描述可以采用状态空间法或者归约描述. 在本问题中,每个数位、操作符状态的组合构成了算式的状态. 单个数位或操作符的变化可以用状态空间表示,将其视为本原问题后,移动若干火柴的问题就可归约为这些本原问题. 本作业采用的方法同时运用了两种描述方法.

本作业题目其实隐含规定了搜索深度.对于原子问题,可以视其为搜索深度为1的BFS; 而两根火柴棍的搜索隐含了与或树的DFS搜索,搜索深度为2.

等式转换的问题的搜索图是隐式的,但状态空间已被极大压缩.可以直接通过某种状态转换的定义方法(这里是字符串汉明距)来求解给定两个节点的距离.

### 5.2 实验反思
通过完成本次编程作业, 我对问题表示和搜索算法的认识得到了进一步加深, 并获得了工程实现搜索算法的能力; 我的``Python``语言的熟练程度也得到了极大提升,对其运作细节也有了更深刻的理解, 并且初步学会运用``PyQt``来实现GUI界面; 

当然,这次作业中不免存在遗憾. 由于作业动工的时间较晚, 加之对``Python``、``PyQt``的不熟悉, 搜索算法实现的重复代码未得到及时重构,导致部分代码冗余; ``PyQt``的GUI界面还不够足够鲁棒和美观; 另外, 由于种种原因, ``Pyinstaller`` 和 ``Py2app`` 生成的 ``.app``始终不能正常工作并没有得到及时解决,故未能正确生成可执行文件 (内部可执行文件错误信息```t.qpa.plugin: Could not find the Qt platform plugin "cocoa" in ""```,可能与我Qt包的安装路径有关). 在完成下次作业时, 还需要进一步熟悉``Python``、``PyQt``和程序打包工具.

## 附录 程序配置/运行环境/版本号
* 操作系统: ``MacOS10.15 Catalina(19A602)``
* 编辑器: 
  * ``Microsoft Visual Studio Code``: ``1.39.2``
  * ``Jupyter Notebook``: ``1.0.0``
* ``Python``: ``3.7.4``
  * ``PyQt5``: ``5.13.0``
  * ``sip``: ``4.19.8``
  * ``Distance``: ``0.1.3``
* 打包工具:
  * ``PyInstaller``: ``3.5``
  * ``py2app``: ``0.19``
